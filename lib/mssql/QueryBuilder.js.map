{"version":3,"sources":["../../src/mssql/QueryBuilder.js"],"names":["QueryBuilder","edm","schema","namer","columns","ascending","map","column","join","desceding","value","Infinity","orderBy","accumulator","ASC","DESC","reduce","Array","isArray","type","push","_createAscendingExpression","_createDescendingExpression","orderByClause","filter","_isNotEmptyFilter","length","query","tableName","mapping","select","keys","Object","getQualifiedTableName","key","_escapeIdentifier","visitor","parse","where","replace","part","parts","_createSelectStatement","_createWhereClause","_createOrderByClause","limit","_createLimitClause","take","offset","_createOffsetClause","skip","_createSelectStatementWithCount"],"mappings":"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","file":"QueryBuilder.js","sourcesContent":["import Visitor from \"./Visitor\";\nimport TableNameHelper from \"./TableNameHelper\";\n\nexport default class QueryBuilder {\n    constructor(edm, schema) {\n        this.edm = edm;\n        this.schema = schema;\n        this.namer = new TableNameHelper({edm:edm, schema:schema});\n    }\n\n    _createAscendingExpression(columns) {\n        let ascending = columns.map((column) => {\n            return \"[\" + column + \"] ASC\";\n        }).join(\", \");\n\n        return ascending;\n    }\n\n    _createDescendingExpression(columns) {\n        let desceding = columns.map((column) => {\n            return \"[\" + column + \"] DESC\";\n        }).join(\", \");\n\n        return desceding;\n    }\n\n    _createLimitClause(value) {\n        if (value === Infinity) {\n            return \"\";\n        } else if (typeof value === \"number\") {\n            return `FETCH NEXT (${value}) ROWS ONLY`;\n        } else {\n            return \"\";\n        }\n    }\n\n    _createOffsetClause(value) {\n        if (typeof value !== \"number\") {\n            value = 0;\n        }\n        return `OFFSET ${value} ROWS`;\n    }\n\n    _createOrderByClause(orderBy) {\n\n        let accumulator = {\n            ASC: [],\n            DESC: []\n        };\n\n        orderBy.reduce((accumulator, orderBy) => {\n            if (Array.isArray(accumulator[orderBy.type])) {\n                accumulator[orderBy.type].push(orderBy.column);\n            }\n            return accumulator;\n        }, accumulator);\n\n        let ascending = this._createAscendingExpression(accumulator.ASC);\n        let desceding = this._createDescendingExpression(accumulator.DESC);\n\n        let orderByClause = [\n            ascending,\n            desceding\n        ].filter(this._isNotEmptyFilter).join(\",\");\n\n        if (orderByClause.length > 0) {\n            return `ORDER BY ${orderByClause}`;\n        } else {\n            return 'ORDER BY (SELECT NULL)';\n        }\n\n    }\n\n    _createSelectStatement(query) {\n        let tableName = query.type;\n        let mapping = query.select;\n        let keys = Object.keys(mapping);\n\n        if (keys.length === 0) {\n            return `SELECT * FROM ${this.namer.getQualifiedTableName(tableName)}`;\n        } else {\n            let columns = keys.map((key) => {\n                return `${this._escapeIdentifier(key)} AS ${this._escapeIdentifier(mapping[key])}`;\n            }).join(\", \");\n\n            return `SELECT ${columns} FROM ${this.namer.getQualifiedTableName(tableName)}`;\n        }\n    }\n\n    _createSelectStatementWithCount(query) {\n        return `SELECT COUNT(*) AS count FROM ${this.namer.getQualifiedTableName(query.type)}`;\n    }\n\n    _createWhereClause(query) {\n        let visitor = new Visitor(query.type, this.edm, this.schema);\n\n        return visitor.parse(query.where);\n    }\n\n    _escapeIdentifier(value) {\n        if (value == null) {\n            return value;\n        }\n\n        return `[${value.replace(/\\\"/g, '\"\"')}]`;\n    }\n\n    _isNotEmptyFilter(part) {\n        return typeof part === \"string\" && part.length > 0;\n    }\n\n    createStatement(query) {\n        let parts = [];\n        let select = this._createSelectStatement(query);\n        let where = this._createWhereClause(query);\n        let orderBy = this._createOrderByClause(query.orderBy);\n        let limit = this._createLimitClause(query.take);\n        let offset = this._createOffsetClause(query.skip);\n\n        parts.push(\n            select,\n            where,\n            orderBy,\n            offset,\n            limit\n        );\n\n        parts = parts.filter(this._isNotEmptyFilter);\n\n        return parts.join(\" \");\n\n    }\n\n    createCountStatement(query) {\n        let parts = [];\n        let select = this._createSelectStatementWithCount(query);\n        let where = this._createWhereClause(query);\n\n        parts.push(\n            select,\n            where\n        );\n\n        parts = parts.filter(this._isNotEmptyFilter);\n\n        return parts.join(\" \");\n\n    }\n}"]}