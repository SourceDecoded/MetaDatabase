{"version":3,"sources":["../../src/mssql/QueryBuilder.js"],"names":["QueryBuilder","edm","schema","tableName","version","replace","columns","ascending","map","column","join","desceding","value","Infinity","orderBy","accumulator","ASC","DESC","reduce","Array","isArray","type","push","_createAscendingExpression","_createDescendingExpression","orderByClause","filter","_isNotEmptyFilter","length","query","mapping","select","keys","Object","_getQualifiedTableName","key","_escapeIdentifier","visitor","parse","where","part","parts","_createSelectStatement","_createWhereClause","_createOrderByClause","limit","_createLimitClause","take","offset","_createOffsetClause","skip","_createSelectStatementWithCount"],"mappings":"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","file":"QueryBuilder.js","sourcesContent":["import Visitor from \"./Visitor\";\n\nexport default class QueryBuilder {\n    constructor(edm, schema) {\n        this.edm = edm;\n        this.schema = schema;\n    }\n\n    _getQualifiedTableName(tableName) {\n        return `[${this.schema}].[${tableName}__${this.edm.version.replace(/\\./g, \"_\")}]`;\n    }\n\n    _createAscendingExpression(columns) {\n        let ascending = columns.map((column) => {\n            return \"[\" + column + \"] ASC\";\n        }).join(\", \");\n\n        return ascending;\n    }\n\n    _createDescendingExpression(columns) {\n        let desceding = columns.map((column) => {\n            return \"[\" + column + \"] DESC\";\n        }).join(\", \");\n\n        return desceding;\n    }\n\n    _createLimitClause(value) {\n        if (value === Infinity) {\n            return \"\";\n        } else if (typeof value === \"number\") {\n            return `FETCH NEXT (${value}) ROWS ONLY`;\n        } else {\n            return \"\";\n        }\n    }\n\n    _createOffsetClause(value) {\n        if (typeof value !== \"number\") {\n            value = 0;\n        }\n        return `OFFSET ${value} ROWS`;\n    }\n\n    _createOrderByClause(orderBy) {\n\n        let accumulator = {\n            ASC: [],\n            DESC: []\n        };\n\n        orderBy.reduce((accumulator, orderBy) => {\n            if (Array.isArray(accumulator[orderBy.type])) {\n                accumulator[orderBy.type].push(orderBy.column);\n            }\n            return accumulator;\n        }, accumulator);\n\n        let ascending = this._createAscendingExpression(accumulator.ASC);\n        let desceding = this._createDescendingExpression(accumulator.DESC);\n\n        let orderByClause = [\n            ascending,\n            desceding\n        ].filter(this._isNotEmptyFilter).join(\",\");\n\n        if (orderByClause.length > 0) {\n            return `ORDER BY ${orderByClause}`;\n        } else {\n            return 'ORDER BY (SELECT NULL)';\n        }\n\n    }\n\n    _createSelectStatement(query) {\n        let tableName = query.type;\n        let mapping = query.select;\n        let keys = Object.keys(mapping);\n\n        if (keys.length === 0) {\n            return `SELECT * FROM ${this._getQualifiedTableName(tableName)}`;\n        } else {\n            let columns = keys.map((key) => {\n                return `${this._escapeIdentifier(key)} AS ${this._escapeIdentifier(mapping[key])}`;\n            }).join(\", \");\n\n            return `SELECT ${columns} FROM ${this._getQualifiedTableName(tableName)}`;\n        }\n    }\n\n    _createSelectStatementWithCount(query) {\n        return `SELECT COUNT(*) AS count FROM ${this._getQualifiedTableName(query.type)}`;\n    }\n\n    _createWhereClause(query) {\n        let visitor = new Visitor(query.type, this.edm, this.schema);\n\n        return visitor.parse(query.where);\n    }\n\n    _escapeIdentifier(value) {\n        if (value == null) {\n            return value;\n        }\n\n        return `[${value.replace(/\\\"/g, '\"\"')}]`;\n    }\n\n    _isNotEmptyFilter(part) {\n        return typeof part === \"string\" && part.length > 0;\n    }\n\n    createStatement(query) {\n        let parts = [];\n        let select = this._createSelectStatement(query);\n        let where = this._createWhereClause(query);\n        let orderBy = this._createOrderByClause(query.orderBy);\n        let limit = this._createLimitClause(query.take);\n        let offset = this._createOffsetClause(query.skip);\n\n        parts.push(\n            select,\n            where,\n            orderBy,\n            offset,\n            limit\n        );\n\n        parts = parts.filter(this._isNotEmptyFilter);\n\n        return parts.join(\" \");\n\n    }\n\n    createCountStatement(query) {\n        let parts = [];\n        let select = this._createSelectStatementWithCount(query);\n        let where = this._createWhereClause(query);\n\n        parts.push(\n            select,\n            where\n        );\n\n        parts = parts.filter(this._isNotEmptyFilter);\n\n        return parts.join(\" \");\n\n    }\n}"]}